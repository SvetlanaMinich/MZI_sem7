# Реализация блочного шифра ГОСТ

Данная папка содержит Python-реализацию алгоритма блочного шифрования ГОСТ (ГОСТ 28147-89) — советского и российского стандарта симметричного шифрования.

## Обзор

Файл `simple_encryption.py` реализует блочный шифр ГОСТ в режиме электронной кодовой книги (ECB) с простой заменой. ГОСТ — это 64-битный блочный шифр, использующий 256-битный ключ и выполняющий 32 раунда шифрования.

## Компоненты алгоритма

### 1. S-блоки (блоки замен)

```python
S_BLOCKS = [
    [4, 10, 9, 2, 13, 8, 0, 14, 6, 11, 1, 12, 7, 15, 5, 3],
    # ... еще 7 S-блоков
]
```

- 8 S-блоков, каждый содержит 16 значений (замена 4 бита на 4 бита)
- Используются для нелинейного преобразования при шифровании
- Каждый S-блок отображает 4-битный вход в 4-битный выход
- Критически важны для безопасности шифра

### 2. Расписание ключей (`generate_subkeys`)

```python
def generate_subkeys(key_256_bit):
```

- Принимает 256-битный главный ключ
- Разделяет его на восемь 32-битных подключей
- Для шифрования: использует подключи по порядку 3 раза, затем в обратном порядке один раз (всего 32 раунда)
- Для дешифрования: обращает всё расписание ключей шифрования

**Схема расписания ключей:**

- Раунды 1-24: K₁, K₂, K₃, K₄, K₅, K₆, K₇, K₈ (повторяется 3 раза)
- Раунды 25-32: K₈, K₇, K₆, K₅, K₄, K₃, K₂, K₁ (обратный порядок)

### 3. Компоненты раундовой функции

#### Модульное сложение (`add_mod_2_32`)

```python
def add_mod_2_32(block, subkey):
    return (block + subkey) & UINT32_MAX
```

- Складывает 32-битный блок с раундовым подключом
- Использует арифметику по модулю 2³² (переполнение на 32 битах)

#### Замена через S-блоки (`s_block_substitution`)

```python
def s_block_substitution(value):
```

- Применяет нелинейное преобразование с использованием S-блоков
- Разделяет 32-битное значение на восемь 4-битных полубайтов
- Каждый полубайт заменяется с использованием соответствующего S-блока
- Обеспечивает перемешивание в шифре

#### Левый циклический сдвиг (`rotate_left`)

```python
def rotate_left(value):
    return ((value << 11) & UINT32_MAX) | (value >> (32 - 11))
```

- Поворачивает 32-битное значение влево на 11 позиций
- Обеспечивает рассеивание в шифре

### 4. Блочное шифрование (`gost_block_crypt`)

```python
def gost_block_crypt(block_64_bit, subkeys):
```

**Структура сети Фейстеля:**

1. Разделить 64-битный блок на две 32-битные половины (A, B)
2. Для каждого из 32 раундов:
   - Применить раундовую функцию к правой половине (B) с раундовым ключом
   - Применить XOR результата с левой половиной (A)
   - Поменять половины местами для следующего раунда
3. Финальная перестановка обеспечивает идентичность дешифрования и шифрования с обращенными ключами

**Раундовая функция (f):**

1. Сложить с раундовым ключом (по модулю 2³²)
2. Применить замену через S-блоки
3. Повернуть влево на 11 бит
4. XOR с левой половиной

### 5. Обработка данных

#### Дополнение (`padding`/`unpadding`)

- Использует дополнение PKCS#7 для блоков, которые не составляют точно 64 бита
- Добавляет байты, равные количеству необходимых байтов дополнения
- Обеспечивает размещение всех данных в 64-битных блоках

#### Функции преобразования

- `bytes_to_int`: Преобразует байтовые данные в целые числа (big-endian)
- `int_to_bytes`: Преобразует целые числа обратно в байты (big-endian)

### 6. Основная функция шифрования (`gost_simple_substitution`)

```python
def gost_simple_substitution(data, subkeys, padding_len=None, encrypt=True):
```

- Реализует режим ECB (электронная кодовая книга)
- Обрабатывает данные в 64-битных блоках независимо
- Каждый блок шифруется/дешифруется отдельно с использованием блочного шифра ГОСТ

## Соображения безопасности

### Сильные стороны:

- 32 раунда обеспечивают сильное рассеивание
- 256-битный размер ключа предлагает хорошее ключевое пространство
- S-блоки обеспечивают нелинейность

### Слабости данной реализации:

- **Режим ECB**: Одинаковые блоки открытого текста производят одинаковые блоки шифротекста
- **Сохранение шаблонов**: Режим ECB не скрывает шаблоны данных
- **Отсутствие аутентификации**: Нет защиты целостности
- **Детерминированность**: Один и тот же открытый текст всегда производит один и тот же шифротекст

## Пример использования

```python
# 256-битный ключ (в двоичном виде)
key = 0b0001000100100010001100110100010001010101011001100111011110001000...

# Генерация подключей
encryption_subkeys, decryption_subkeys = generate_subkeys(key)

# Шифрование
original_text = "Test message"
original_bytes = original_text.encode('utf-8')
encrypted, padding_len = gost_simple_substitution(original_bytes, encryption_subkeys, encrypt=True)

# Дешифрование
decrypted, _ = gost_simple_substitution(encrypted, decryption_subkeys, padding_len, encrypt=False)
```

## Математические основы

Шифр ГОСТ основан на:

1. **Сеть Фейстеля**: Обеспечивает обратимость без необходимости обратных функций
2. **Сеть замена-перестановка**: S-блоки (замена) + поворот (перестановка)
3. **Модульная арифметика**: Сложение по модулю 2³² для смешивания ключей
4. **Операции XOR**: Для объединения выхода раундовой функции с данными

## Образовательная цель

Данная реализация демонстрирует:

- Принципы проектирования классических блочных шифров
- Конструкцию сети Фейстеля
- Алгоритмы расписания ключей
- Базовые криптографические операции (замена, перестановка, модульная арифметика)
- Режим работы ECB (и его ограничения)

**Примечание**: Данная реализация предназначена для образовательных целей. Для производственного использования рассмотрите:

- Использование режимов аутентифицированного шифрования (GCM, CCM)
- Реализацию правильной генерации случайных IV/nonce
- Использование установленных криптографических библиотек
- Следование современным лучшим практикам безопасности
